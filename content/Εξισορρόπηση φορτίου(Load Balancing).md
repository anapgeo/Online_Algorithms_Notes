## To πρόβλημα

- Διαθέτουμε m πανομοιότυπες μηχανές 
- Θέλουμε να εξυπηρετήσουμε n εργασίες οι οποίες έρχονται σειριακά 1,2,..,n
- Κάθε εργασία $j$ πρέπει να εκτελεστεί συνεχόμενα σε μια μηχανή και χρειάζεται χρόνο $t_j$ για να ολοκληρωθεί
- Κάθε μηχανή μπορεί να διεκπεραιώνει μόνο μια εργασία κάθε χρονική στιγμή
- Ο αλγόριθμος δεν γνωρίζει τίποτα για τις εργασίες που ακολουθούν αυτής που του έρχεται πως εξυπηρέτηση κάθε χρονική στιγμή, αλλά θα πρέπει να λάβει την απόφαση σε ποια μηχανή θα δώσει την εργασία που λαμβάνει

Κλασσικό παράδειγμα προβλήματος Load Balancing είναι όταν έχουμε κάποιους πανομοιότυπους servers οι οποίοι δέχονται με online τρόπο μια σειρά από αιτήματα να κάνουν κάποιες εργασίες. Πως θα πρέπει να κατανείμουμε τις εργασίες σε αυτούς τους servers ώστε να έχουμε τη μικρότερη δυνατή καθυστέρηση;

Ορίζουμε:

- $S[i]$: το υποσύνολο των εργασιών που ανατίθενται στη μηχανή $i$
- $L[i]=\sum_{j \in S[i]}t_j$ : το φορτίο της μηχανής $i$ (με άλλα λόγια πόσο χρόνο χρειάζεται η μηχανή $i$ να φέρει σε πέρας τις εργασίες οι οποίες της έχουν ανατεθεί)
- $L=\max_i L[i]$ : διάρκεια εκτέλεση ή αλλιώς makespan, είναι το μέγιστο φορτίο μεταξύ όλων των μηχανών (δηλαδή ο χρόνος που απαιτείτε για να τελειώσουν όλες οι μηχανές)

Πρακτικά ο στόχος μας είναι να έχουμε όσο το δυνατό μικρότερο makespan, για να το επιτυχουμε αυτό ουσιαστικά θα πρέπει να επιτύχουμε μια εξισορρόπηση των φορτίων στις μηχανές. Για αυτό και το πρόβλημα ονομάζεται Load Balancing.

![[Screenshot_12.png]]


Γενικά ακόμα και στην μη online περίπτωση όπου γνωρίζουμε τα πάντα για τις εργασίες που πρέπει να εκτελέσουμε και έχουμε μόνο 2 διαθέσιμες μηχανές, το πρόβλημα εύρεσης της βέλτιστης λύσης είναι NP-hard.

## Ένας άπληστος αλγόριθμος

### Υλοποίηση 
Θα αναλύσουμε ένα απλό άπληστο αλγόριθμο για την επίλυση του προβλήματος που αναλύσαμε πρηγουμένως. Ο αλγόριθμος αυτός ονομάζεται List-scheduling. Η ιδέα πίσω από αυτόν τον αλγόριθμο είναι ιδιαίτερα απλή: Κάθε φορά που λαμβάνεις μια νέα εργασία $j$ ανέθεσε τη στη μηχανή $i$ η οποία έχει το μικρότερο φόρτο εργασίας τη δεδομένη χρονική στιγμή


![[Screenshot_13.png]]

*Πολυπλοκότητα*: $Ο(nlogm)$ με τη χρήση ουράς προτεραιότητας για τα φορτία $L[k]$(αυτό μας εξασφαλίζει πως μπορούμε να ανακτήσουμε τη μηχανή με το μικρότερο φορτίο σε μια εντολή χωρίς καθυστέρηση)

### Ανάλυση

Πόσο καλά τα πάει ο αλγόριθμος μας σε σχέση με τη βέλτιστη λύση; Έχει αποδειχτεί από το Graham το 1966 πως ο λόγος προσέγγισης του αλγορίθμου αυτού είναι το πολύ 2. Δηλαδή δεν μπορούμε να καθυστερήσουμε περισσότερο από το διπλάσιο της βέλτιστης καθυστέρησης.

Για να αποδείξουμε το παραπάνω αρχικά θα χρησιμοποιήσουμε τα παρακάτω λήμματα:

Λήμμα 1:
> Για όλα τα k: το βέλτιστο makespan $L^* \geq t_k$ -> Με απλά λόγια ο χρόνος εκτέλεσης όλων των εργασιών δεν μπορεί να είναι μικρότερος από το χρόνο εκτέλεσης της πιο χρονοβόρας εργασίας

Λήμμα 2:
> Το βέλτιστο makespan $L^* \geq \frac{1}{m}\sum_k t_k$ -> Ο συνολικός χρόνος εκτέλεσεις θα πρέπει να είναι τουλάχιστον 1/m κλάσμα του συνολικού χρόνου που απαιτουν όλες οι εργασίες αν εκτελούνταν σειριακά. Μπορείς να το σκεφτείς ως εξης: Έστω πως στην αρχή είχες μόνο μια μηχανή, τότε ο συνολικός χρόνος θα ήταν $\sum_k t_k$. Αν τώρα μας δώσουν m ίδιες με την αρχική μηχανές, αν οι εργασίες αυτές είναι ίδιες, άρα όλα τα $t_k$ είναι ίδια, τότε ο απαιτούμενος χρόνος θα είναι $\frac{1}{m}\sum_k t_k$. Στην περίπτωση των ανόμοιων εργασιών όπως και να τις χωρίσουμε είναι αδύνατο κάποια μηχανή να μην περνάει το όριο του $\frac{1}{m}\sum_k t_k$. 